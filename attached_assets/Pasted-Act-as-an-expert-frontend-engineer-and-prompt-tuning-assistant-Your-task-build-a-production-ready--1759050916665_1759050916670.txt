Act as an expert frontend engineer and prompt-tuning assistant. Your task: build a production-ready frontend for Tugasin — a platform providing academic task and thesis assistance. The output must be SEO-first, fully crawlable by search engine bots, performance-optimized, modular, and maintainable. Use a structured architecture with modern practices, not a single-file implementation. Blog content should come from a headless CMS (WordPress GraphQL endpoint at https://cms.tugasin.me/graphql) using the provided query `GetAllPostsWithSEO`, with proper pagination support. Deliver a solution that is deployment-ready, well-refactored, standardized, cleanly organized, and follows the rules below.

Rules:
1. Never hardcode values such as URLs, API keys, query variables, site titles, meta information, pagination limits, or static copy inside components. Use environment variables, configuration files, or CMS-provided fields.
2. All sensitive or dynamic data must be injected from config, environment, or CMS — not directly inside code.
3. Queries, limits, and settings (e.g., posts per page, site metadata, canonical domain) should be defined in config or environment, then imported wherever needed.
4. Components must not contain inline “magic numbers” or static strings that should come from config or CMS. Example: pagination limit, SEO defaults, or service descriptions.
5. Always separate concerns: UI in components, data in queries/hooks, constants in config, and secrets in environment.

1. Goals and priorities
   - Build a production-ready frontend for Tugasin with pages: homepage, services, blog, and contact.
   - SEO-friendly (server-side rendering, structured data, sitemaps, meta tags).
   - Fast, mobile-first, accessible (WCAG basics).
   - Modular, maintainable, refactored, no “all-in-one” files.
   - Secure integration with the CMS and proper sanitization of dynamic content.

2. Tech stack and architecture
   - Framework: Next.js (latest) with TypeScript.
   - Styling: Tailwind CSS or CSS Modules.
   - Data fetching: Apollo Client or graphql-request for GraphQL + SWR/React Query for caching and state management.
   - Rendering strategy: SSG/ISR for static marketing pages, ISR or SSR for blog posts and listing.
   - Routing: Next.js file-based routing with dynamic `[slug]` for blog posts.
   - Images: Next/Image for optimization, fallback to CMS image URLs.
   - SEO: meta tags, Open Graph, Twitter Card, canonical links, JSON-LD structured data.
   - Sitemap.xml and robots.txt generated automatically.

3. GraphQL integration
   - Endpoint: https://cms.tugasin.me/graphql (store in environment variable, e.g., NEXT_PUBLIC_CMS_ENDPOINT).
   - Query: implement `GetAllPostsWithSEO($first: Int!, $after: String)` as provided.
   - Pagination: use `endCursor` and `hasNextPage` from `pageInfo` to fetch subsequent pages.
   - Handle fields: use SEO fields (`seo.title`, `seo.description`, `seo.canonicalUrl`), featured images (`featuredImage.node.sourceUrl` or `fifuImageUrl`), and sanitized `content`.

4. Caching strategy
   - Use ISR (Incremental Static Regeneration) with `revalidate` for blog listing and posts, ensuring fresh content without heavy rebuilds.
   - Client-side caching: SWR/React Query for “load more” pagination and dynamic queries.
   - GraphQL response caching with Apollo in-memory cache or edge caching (if deployed on Vercel/Netlify).
   - HTTP caching: set proper Cache-Control headers for static assets, images, and API responses.
   - Optimize with CDN-level caching where available.
   - Ensure cache invalidation strategies are in place to avoid stale SEO data.

5. Project structure (example)
   - /src
     - /pages
       - index.tsx (homepage, getStaticProps)
       - /services/index.tsx
       - /blog/index.tsx (paginated listing)
       - /blog/[slug].tsx (dynamic post page)
       - /contact/index.tsx
       - _app.tsx, _document.tsx
     - /components
       - layout (Header, Footer, SEO, Container)
       - ui (Button, Card, Link)
       - blog (PostCard, PostContent)
       - services (ServiceCard)
     - /lib (graphql client, cms queries, seo helpers, sitemap generator)
     - /config (constants, site metadata, defaults)
     - /styles
     - /types (GraphQL and CMS types)
     - /utils (date formatting, sanitization)
     - /hooks (pagination, metadata)
     - /tests

6. SEO and crawlability
   - Dynamic meta tags from CMS `seo` fields.
   - Canonical URLs, Open Graph, and Twitter Card metadata.
   - Structured data with JSON-LD (Organization, Website, BreadcrumbList, Article).
   - Sitemap.xml includes homepage, services, contact, all blog posts (updated via ISR).
   - robots.txt configured for search engine bots.
   - Server-side rendering/SSG ensures full HTML content is visible to crawlers.

7. Performance and PWA considerations
   - Optimize images with Next/Image and modern formats (WebP).
   - Use dynamic imports for non-critical components.
   - Implement Lighthouse optimizations: preload critical assets, reduce bundle size, async/defer scripts.
   - Provide caching headers for static and dynamic content.
   - Optional PWA setup: service worker, offline caching for static assets.

8. Security
   - No exposure of CMS secrets in client bundle.
   - Sanitize HTML content from CMS before rendering (e.g., DOMPurify).
   - Rate-limit or validate contact form submissions.
   - Secure headers and HTTPS enforced on deployment.

Query:
query GetAllPostsWithSEO($first: Int!, $after: String) {
  posts(first: $first, after: $after) {
    pageInfo {
      hasNextPage
      endCursor
    }
    nodes {
      id
      databaseId
      title
      slug
      excerpt
      date
      featuredImage {
        node {
          sourceUrl
        }
      }
      fifuImageUrl
      seo {
        title
        description
        focusKeywords
        seoScore {
          score
        }
        canonicalUrl
      }
      author {
        node {
          id
          name
          slug
        }
      }
      categories {
        nodes {
          id
          name
          slug
        }
      }
      tags {
        nodes {
          id
          name
          slug
        }
      }
      content
    }
  }
}